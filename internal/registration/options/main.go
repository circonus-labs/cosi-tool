// Copyright Â© 2018 Circonus, Inc. <support@circonus.com>
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package options

import (
	"encoding/json"
	"fmt"
	"io"
	"net"
	"os"
	"regexp"
	"strings"

	"github.com/circonus-labs/cosi-tool/internal/config"
	toml "github.com/pelletier/go-toml"
	"github.com/pkg/errors"
	"github.com/rs/zerolog/log"
	"github.com/spf13/viper"
	yaml "gopkg.in/yaml.v2"
)

// Options defines the options available for --regconf config file command line option.
type Options struct {
	Brokers    `json:"brokers" toml:"brokers" yaml:"brokers"`
	Checks     `json:"checks" toml:"checks" yaml:"checks"`
	Dashboards `json:"dashboards" toml:"dashboards" yaml:"dashboards"`
	Graphs     `json:"graphs" toml:"graphs" yaml:"graphs"`
	Host       `json:"host" toml:"host" yaml:"host"`
	Worksheets `json:"worksheets" toml:"worksheets" yaml:"worksheets"`
	Common     `json:"-" toml:"-" yaml:"-"` // cannot be set in config, generated by cosi register
}

// Brokers defines settings for broker selection
type Brokers struct {
	Group  GroupBrokers  `json:"group" toml:"group" yaml:"group"`
	System SystemBrokers `json:"system" toml:"system" yaml:"system"`
}

// SystemBrokers defines broker settings for system check
// NOTE: broker must have the 'json:nad' check available
type SystemBrokers struct {
	Default int      `json:"default" toml:"default" yaml:"default"` // offset into list or -1 for random
	List    []string `json:"list" toml:"list" yaml:"list"`          // list of valid broker ids - e.g. '/broker/123'
}

// GroupBrokers defines broker settings for group check
// NOTE: broker must have the 'httptrap' check available
type GroupBrokers struct {
	Default int      `json:"default" toml:"default" yaml:"default"` // offset into list or -1 for random
	List    []string `json:"list" toml:"list" yaml:"list"`          // list of valid broker ids - e.g. '/broker/123'
}

// Host defines the host overrides for registration
type Host struct {
	IP   string `json:"ip" toml:"ip" yaml:"ip"`
	Name string `json:"name" toml:"name" yaml:"name"`
}

// Checks defines the checks supporting overrides
type Checks struct {
	Group  GroupCheck  `json:"group" toml:"group" yaml:"group"`
	System SystemCheck `json:"system" toml:"system" yaml:"system"`
}

// SystemCheck defines the system check overrides for registration
type SystemCheck struct {
	BrokerID      string     `json:"broker_id" toml:"broker_id" yaml:"broker_id"`
	DisplayName   string     `json:"display_name" toml:"display_name" yaml:"display_name"`
	Tags          []string   `json:"tags" toml:"tags" yaml:"tags"`
	Target        string     `json:"target" toml:"target" yaml:"target"`
	MetricFilters [][]string `json:"metric_filters" toml:"metric_filters" yaml:"metric_filters"`
}

// GroupCheck defines the group check overrides for registration
type GroupCheck struct {
	BrokerID      string     `json:"broker_id" toml:"broker_id" yaml:"broker_id"`
	Create        bool       `json:"create" toml:"create" yaml:"create"`
	DisplayName   string     `json:"display_name" toml:"display_name" yaml:"display_name"`
	ID            string     `json:"id" toml:"id" yaml:"id"`
	Tags          []string   `json:"tags" toml:"tags" yaml:"tags"`
	MetricFilters [][]string `json:"metric_filters" toml:"metric_filters" yaml:"metric_filters"`
}

// Dashboards defines the dashbaords supporting overrides
type Dashboards struct {
	System SystemDashboard `json:"system" toml:"system" yaml:"system"`
}

// SystemDashboard defines the system dashboard overrides for registration
type SystemDashboard struct {
	Create bool   `json:"create" toml:"create" yaml:"create"`
	Title  string `json:"title" toml:"title" yaml:"title"`
}

// Graphs defines the graphs supporting overrides
type Graphs struct {
	Configs map[string]map[string]Graph `json:"configs" toml:"configs" yaml:"configs"`
	Exclude []string                    `json:"exclude" toml:"exclude" yaml:"exclude"`
	Include []string                    `json:"include" toml:"include" yaml:"include"`
}

// Graph defines the generic graph overrides for registration
type Graph struct {
	Tags  []string `json:"tags" toml:"tags" yaml:"tags"`
	Title string   `json:"title" toml:"title" yaml:"title"`
}

// Worksheets defines the worksheets supporting overrides
type Worksheets struct {
	System SystemWorksheet `json:"system" toml:"system" yaml:"system"`
}

// SystemWorksheet defines the system worksheet overrides for registration
type SystemWorksheet struct {
	Create      bool     `json:"create" toml:"create" yaml:"create"`
	Description string   `json:"description" toml:"description" yaml:"description"`
	Tags        []string `json:"tags" toml:"tags" yaml:"tags"`
	Title       string   `json:"title" toml:"title" yaml:"title"`
}

// Common are a set of non-configurable options which are dynamically generated
type Common struct {
	Notes string   `json:"-" toml:"-" yaml:"-"`
	Tags  []string `json:"-" toml:"-" yaml:"-"`
}

// LoadConfigFile reads a custom options configuration file and returns an Options struct
func LoadConfigFile(fn string) (*Options, error) {
	logger := log.With().Str("cmd", "register").Str("pkg", "options").Logger()

	agentMode := viper.GetString(config.KeyAgentMode)
	isReverse := false
	if agentMode == "" || agentMode == "reverse" {
		isReverse = true
	}

	cfg := Options{}
	if fn == "" {
		logger.Warn().Msg("no custom configuration provided, skipping")
	} else {
		logger.Info().Str("reg_conf", fn).Msg("loading custom configuration file")
		if err := config.LoadConfigFile(fn, &cfg); err != nil {
			if !strings.Contains(err.Error(), "no config found matching") {
				return nil, err
			}
		}
	}

	//
	// Host settings
	//
	if cfg.Host.Name == "" {
		if viper.GetString(config.KeyHostTarget) != "" {
			cfg.Host.Name = viper.GetString(config.KeyHostTarget)
		} else {
			hn, err := os.Hostname()
			if err != nil {
				return nil, err
			}
			cfg.Host.Name = hn
		}
	}
	if cfg.Host.IP == "" && cfg.Checks.System.Target == "" {
		addrs, err := net.LookupHost(cfg.Host.Name)
		if err != nil {
			if !isReverse {
				return nil, err
			}
		}
		if len(addrs) > 0 {
			cfg.Host.IP = addrs[0]
		} else {
			cfg.Host.IP = cfg.Host.Name
		}
	}
	if cfg.Checks.System.Target == "" {
		if viper.GetString(config.KeyAgentMode) == "reverse" {
			cfg.Checks.System.Target = "REV:" + cfg.Host.Name
		} else {
			cfg.Checks.System.Target = cfg.Host.IP
		}
	}

	// Broker
	brokerID := ""
	if viper.GetString(config.KeyHostBrokerID) != "" && viper.GetString(config.KeyHostBrokerID) != "0" {
		// NOTE: a broker id set in the config or on the command line
		//       must support the types of checks needed or check
		//       creation will fail. it also must be reachable...
		//       - system needs a broker with the json noit module
		//       - group needs a broker with the httptrap noit module
		brokerID = viper.GetString(config.KeyHostBrokerID)
	}
	if brokerID != "" {
		rxBrokerCID := regexp.MustCompile(`^/broker/[0-9]+$`)
		if !rxBrokerCID.MatchString(brokerID) {
			if regexp.MustCompile(`^[0-9]+$`).MatchString(brokerID) {
				brokerID = "/broker/" + brokerID
			}
		}
		if !rxBrokerCID.MatchString(brokerID) {
			return nil, errors.Errorf("invalid broker id specified (%s) - format should be '#' or '/broker/#'.", brokerID)
		}
	}
	if cfg.Checks.System.BrokerID == "" {
		cfg.Checks.System.BrokerID = brokerID
	}

	if viper.GetString(config.KeyHostGroupID) != "" {
		// command line takes precedence
		// use one flag for both setting group id and toggling creation
		cfg.Checks.Group.ID = viper.GetString(config.KeyHostGroupID)
		cfg.Checks.Group.Create = true
		if cfg.Checks.Group.BrokerID == "" {
			cfg.Checks.Group.BrokerID = brokerID
		}
	}
	// disable if enabled and no group id set
	if cfg.Checks.Group.Create && cfg.Checks.Group.ID == "" {
		cfg.Checks.Group.Create = false
	}

	cosiID := viper.GetString(config.KeyCosiID)
	if cosiID == "" {
		return nil, errors.New("cosi_id not set")
	}

	cfg.Common.Notes = "cosi:register,cosi_id:" + cosiID
	cfg.Common.Tags = []string{
		"cosi:install",
		"distro:" + viper.GetString(config.KeySystemOSDistro) + "-" + viper.GetString(config.KeySystemOSVersion),
		"arch:" + viper.GetString(config.KeySystemArch),
		"os:" + viper.GetString(config.KeySystemOSType),
	}

	return &cfg, nil
}

// DumpConfig prints the running configuration
func DumpConfig(cfg *Options, format string, w io.Writer) error {
	var err error
	var data []byte

	switch format {
	case "json":
		data, err = json.MarshalIndent(cfg, " ", "  ")
		if err != nil {
			return errors.Wrap(err, "formatting config (json)")
		}
	case "yaml":
		data, err = yaml.Marshal(cfg)
		if err != nil {
			return errors.Wrap(err, "formatting config (yaml)")
		}
	case "toml":
		data, err = toml.Marshal(*cfg)
		if err != nil {
			return errors.Wrap(err, "formatting config (toml)")
		}
	default:
		return errors.Errorf("unknown config format '%s'", format)
	}

	fmt.Fprintf(w, "\n%s\n", data)
	return nil
}

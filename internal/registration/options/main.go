// Copyright Â© 2018 Circonus, Inc. <support@circonus.com>
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package options

import (
	"net"
	"os"
	"path"
	"regexp"
	"strings"

	"github.com/circonus-labs/cosi-tool/internal/config"
	"github.com/circonus-labs/cosi-tool/internal/config/defaults"
	"github.com/pkg/errors"
	"github.com/rs/zerolog/log"
	"github.com/spf13/viper"
)

// Options defines the options available for --regconf config file command line option.
type Options struct {
	Brokers    `json:"brokers" toml:"brokers" yaml:"brokers"`
	Checks     `json:"checks" toml:"checks" yaml:"checks"`
	Dashboards `json:"dashboards" toml:"dashboards" yaml:"dashboards"`
	Graphs     `json:"graphs" toml:"graphs" yaml:"graphs"`
	Host       `json:"host" toml:"host" yaml:"host"`
	Worksheets `json:"worksheets" toml:"worksheets" yaml:"worksheets"`
	Common     // cannot be set in config, generated by cosi register
}

// Brokers defines settings for broker selection
type Brokers struct {
	SystemBrokers `json:"system" toml:"system" yaml:"system"`
	GroupBrokers  `json:"group" toml:"group" yaml:"group"`
}

// SystemBrokers defines broker settings for system check
// NOTE: broker must have the 'json:nad' check available
type SystemBrokers struct {
	List    []string `json:"list" toml:"list" yaml:"list"`          // list of valid broker ids - e.g. '/broker/123'
	Default int      `json:"default" toml:"default" yaml:"default"` // offset into list or -1 for random
}

// GroupBrokers defines broker settings for group check
// NOTE: broker must have the 'httptrap' check available
type GroupBrokers struct {
	List    []string `json:"list" toml:"list" yaml:"list"`          // list of valid broker ids - e.g. '/broker/123'
	Default int      `json:"default" toml:"default" yaml:"default"` // offset into list or -1 for random
}

// Host defines the host overrides for registration
type Host struct {
	IP   string `json:"ip" toml:"ip" yaml:"ip"`
	Name string `json:"name" toml:"name" yaml:"name"`
}

// Checks defines the checks supporting overrides
type Checks struct {
	Group  GroupCheck  `json:"group" toml:"group" yaml:"group"`
	System SystemCheck `json:"system" toml:"system" yaml:"system"`
}

// SystemCheck defines the system check overrides for registration
type SystemCheck struct {
	BrokerID    string   `mapstructure:"broker_id" json:"broker_id" toml:"broker_id" yaml:"broker_id"`
	DisplayName string   `mapstructure:"display_name" json:"display_name" toml:"display_name" yaml:"display_name"`
	Tags        []string `json:"tags" toml:"tags" yaml:"tags"`
	Target      string   `json:"target" toml:"target" yaml:"target"`
}

// GroupCheck defines the group check overrides for registration
type GroupCheck struct {
	BrokerID    string   `mapstructure:"broker_id" json:"broker_id" toml:"broker_id" yaml:"broker_id"`
	Create      bool     `json:"create" toml:"create" yaml:"create"`
	DisplayName string   `mapstructure:"display_name" json:"display_name" toml:"display_name" yaml:"display_name"`
	ID          string   `json:"id" toml:"id" yaml:"id"`
	Tags        []string `json:"tags" toml:"tags" yaml:"tags"`
}

// Dashboards defines the dashbaords supporting overrides
type Dashboards struct {
	System SystemDashboard `json:"system" toml:"system" yaml:"system"`
}

// SystemDashboard defines the system dashboard overrides for registration
type SystemDashboard struct {
	Create bool   `json:"create" toml:"create" yaml:"create"`
	Title  string `json:"title" toml:"title" yaml:"title"`
}

// Graphs defines the graphs supporting overrides
type Graphs struct {
	Configs map[string]map[string]Graph `json:"configs" toml:"configs" yaml:"configs"`
	Exclude []string                    `json:"exclude" toml:"exclude" yaml:"exclude"`
	Include []string                    `json:"include" toml:"include" yaml:"include"`
}

// Graph defines the generic graph overrides for registration
type Graph struct {
	Title string   `json:"title" toml:"title" yaml:"title"`
	Tags  []string `json:"tags" toml:"tags" yaml:"tags"`
}

// Worksheets defines the worksheets supporting overrides
type Worksheets struct {
	System SystemWorksheet `json:"system" toml:"system" yaml:"system"`
}

// SystemWorksheet defines the system worksheet overrides for registration
type SystemWorksheet struct {
	Create      bool     `json:"create" toml:"create" yaml:"create"`
	Title       string   `json:"title" toml:"title" yaml:"title"`
	Description string   `json:"description" toml:"description" yaml:"description"`
	Tags        []string `json:"tags" toml:"tags" yaml:"tags"`
}

// Common are a set of non-configurable options which are dynamically generated
type Common struct {
	Tags  []string
	Notes string
}

const (
	// KeyRegConf is the custom options registration configuration
	KeyRegConf = "reg.conf"
	// KeyGroupID is the group check id to use when creating a group check for agent statsd
	KeyGroupID = "checks.group.id"
	// KeyBrokerID defines the default/general broker id (if not set, one will be selected)
	// A broker id may also be set on each individual check
	KeyBrokerID = "checks.broker_id"
)

var (
	// DefaultRegConf is the default custom options registration configuration base file name
	DefaultRegConf = path.Join(defaults.EtcPath, "regconf") // NOTE: loader will try each ext (json,toml,yaml)
)

// LoadConfigFile reads a custom options configuration file and returns an Options struct
func LoadConfigFile(fn string) (*Options, error) {
	logger := log.With().Str("cmd", "register").Str("pkg", "options").Logger()

	agentMode := viper.GetString(config.KeyAgentMode)
	isReverse := false
	if agentMode == "" || agentMode == "reverse" {
		isReverse = true
	}

	cfg := Options{}
	if fn == "" {
		logger.Warn().Msg("no custom configuration provided, skipping")
	} else {
		if err := config.LoadConfigFile(fn, &cfg); err != nil {
			if !strings.Contains(err.Error(), "no config found matching") {
				return nil, err
			}
		}
	}

	//
	// Host settings
	//
	if cfg.Host.Name == "" {
		hn, err := os.Hostname()
		if err != nil {
			return nil, err
		}
		cfg.Host.Name = hn
	}
	if cfg.Host.IP == "" && cfg.Checks.System.Target == "" {
		addrs, err := net.LookupHost(cfg.Host.Name)
		if err != nil {
			if !isReverse {
				return nil, err
			}
		}
		if len(addrs) > 0 {
			cfg.Host.IP = addrs[0]
		} else {
			cfg.Host.IP = cfg.Host.Name
		}
	}
	if cfg.Checks.System.Target == "" {
		if viper.GetString(config.KeyAgentMode) == "reverse" {
			cfg.Checks.System.Target = "REV:" + cfg.Host.Name
		} else {
			cfg.Checks.System.Target = cfg.Host.IP
		}
	}

	// Broker
	brokerID := ""
	if viper.GetString(KeyBrokerID) != "" {
		// NOTE: a broker id set in the config or on the command line
		//       must support the types of checks needed or check
		//       creation will fail. it also must be reachable...
		//       - system needs a broker with the json noit module
		//       - group needs a broker with the httptrap noit module
		brokerID = viper.GetString(KeyBrokerID)
	}
	if brokerID != "" {
		rxBrokerCID := regexp.MustCompile(`^/broker/[0-9]+$`)
		if !rxBrokerCID.MatchString(brokerID) {
			if regexp.MustCompile(`^[0-9]+$`).MatchString(brokerID) {
				brokerID = "/broker/" + brokerID
			}
		}
		if !rxBrokerCID.MatchString(brokerID) {
			return nil, errors.Errorf("invalid broker id specified (%s) - format should be '#' or '/broker/#'.", brokerID)
		}
	}
	if cfg.Checks.System.BrokerID == "" {
		cfg.Checks.System.BrokerID = brokerID
	}

	if viper.GetString(KeyGroupID) != "" {
		// command line takes precedence
		// use one flag for both setting group id and toggling creation
		cfg.Checks.Group.ID = viper.GetString(KeyGroupID)
		cfg.Checks.Group.Create = true
		if cfg.Checks.Group.BrokerID == "" {
			cfg.Checks.Group.BrokerID = brokerID
		}
	}
	// disable if enabled and no group id set
	if cfg.Checks.Group.Create && cfg.Checks.Group.ID == "" {
		cfg.Checks.Group.Create = false
	}

	cosiID := viper.GetString(config.KeyCosiID)
	if cosiID == "" {
		return nil, errors.New("cosi_id not set")
	}

	cfg.Common.Notes = "cosi:register,cosi_id:" + cosiID
	cfg.Common.Tags = []string{
		"cosi:install",
		"distro:" + viper.GetString(config.KeySystemOSDistro) + "-" + viper.GetString(config.KeySystemOSVersion),
		"arch:" + viper.GetString(config.KeySystemArch),
		"os:" + viper.GetString(config.KeySystemOSType),
	}

	return &cfg, nil
}
